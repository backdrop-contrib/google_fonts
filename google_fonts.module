<?php

/**
 * @file
 * This module enables Google Fonts on your website.
 *
 * This module enables you to load fonts from the Google Fonts API
 * within your website. After selecting which fonts you want to use 
 * they will become available as working font-families in your CSS.
 */

/**
 * Implements hook_menu().
 */
function google_fonts_menu() {
  $items = array();

  $items['admin/config/system/google_fonts'] = array(
    'title' => 'Google Fonts',
    'description' => 'Select the Google Fonts you want to be available in your CSS.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('google_fonts_admin_settings_form'),
    'access arguments' => array('administer site configuration'),
    'file' => 'google_fonts.admin.inc',
  );
  
  $items['admin/config/system/google_fonts/select'] = array(
    'title' => 'Select fonts',
    'description' => 'Select the Google Fonts to use.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('google_fonts_admin_settings_form'),
    'access arguments' => array('administer site configuration'),
    'file' => 'google_fonts.admin.inc',
    'type' => MENU_DEFAULT_LOCAL_TASK,
  );

  return $items;
}

/**
 * Implements hook_init().
 */
function google_fonts_init() {
  
  // We don't need to load the fonts twice as the admin interface
  // loads ALL fonts by default already
  if ($_GET['q'] == 'admin/config/system/google_fonts') {
    return;
  }

  _google_fonts_add_custom_css();
  
  $fonts_to_load = array();
  $enabled_fonts = variable_get('google_fonts_enabled_fonts', array());
  
  // Check if Google Fonts array has been converted yet
  if (!empty($used_fonts) && !isset($used_fonts[0]) && user_access('administer software updates')) {
    drupal_set_message(t('You have not updated your Google Fonts module yet. Please run the database update script.'), 'error');
  }

  foreach ($enabled_fonts as $font) { 
    $fonts_to_load[] = _google_fonts_family_pathname($font['family'], $font['variants'], $font['subsets']);
  }
  if (!empty($fonts_to_load)) {
    _google_fonts_load_css($fonts_to_load, 1);
  }
}

function _google_fonts_add_custom_css() {
  // Fetch the CSS code to be created
  $css_contents = '\/* CSS code for the Google Fonts module *\/' . 
                  PHP_EOL . 
                  variable_get("google_fonts_css_contents", '');
                  
  // Now add it to the list of CSS files to be loaded
  drupal_add_css(
    _google_fonts_cache($css_contents), 
    array('type' => 'file', 'every_page' => TRUE, 'group' => CSS_THEME)
  );
}

/**
 * Add the CSS include to the HEAD of the page
 */
function _google_fonts_load_css($fonts_to_load, $chunksize = 15) {
  $protocol = (!empty($_SERVER['HTTPS']) && $_SERVER['HTTPS'] == 'on') ? 'https' : 'http';
  
  $chunks = array_chunk($fonts_to_load, $chunksize);
  foreach ($chunks as $chunk) {
    drupal_add_css($protocol . '://fonts.googleapis.com/css?family=' . implode('|', $chunk), array('type' => 'external', 'weight' => CSS_SYSTEM));
  }
}

/**
 * Provides all needed details about Google fonts.
 * Thanks at @sreynen to provide this array in his @font-your-face module
 */
function _google_fonts_available_fonts() {
  $fontsbuffer = variable_get('google_fonts_webfonts', array());
  if (empty($fontsbuffer)) {
    // Return the JSON object with all available fonts
    // For now, it uses my (BarisW) API key
    
    // This key is limited to 10.000 requests per day, which should
    // be sufficient as it is only used when selecting fonts in the
    // admin interface. After that, it's cached in Drupal.
    $result = drupal_http_request('https://www.googleapis.com/webfonts/v1/webfonts?key=AIzaSyBgeqKlFdYj3Y7VwmrEXnXzpnx5TfKXG4o');
    if ($result->status_message != 'OK') {
      return FALSE;
    }
    $fontsbuffer = json_decode($result->data);
    variable_set('google_fonts_webfonts', $fontsbuffer->items);
  }
  return $fontsbuffer;
}

/**
 * Format the font name as saved in the database (underscores instead of spaces)
 */
function _google_fonts_system_fontname($string) {
  return str_replace(' ', '_', $string);
}

function _google_fonts_family_pathname($family, $variants = NULL, $subset = NULL) {
  $string = str_replace(' ', '+', $family);
  
  if ($variants) {
    if (sizeof($variants) == 1) {
      unset($variants['regular']);
    }
    if ($variants) {
      $string .= ':' . implode(',', $variants);
    }
  }
  
  // for latin, we don't need to declare a subset. 
  // for other subsets, include latin as well
  if ($subset && $subset != 'latin') {
    $string .= '&subset=' . $subset . ',latin';
  }
  
  return $string;
}

function _google_fonts_family_array_key_encode($string) {
  return str_replace(' ', '_', $string);
}

function _google_fonts_family_array_key_decode($string) {
  $string = str_replace('__', ':', $string);
  $string = str_replace('_', ' ', $string);
  return $string;
}

/**
 * Return the path of this font
 * If it is a child font of a larger family, scan the array to determine its path
 */
function _google_fonts_get_font_info($font, $full_font = '') {
  $available_fonts = _google_fonts_available_fonts();
    
  if (empty($full_font)) {
    $full_font = $font;
  }
  if (isset($available_fonts[$font]['fonts'])) {
    if (isset($available_fonts[$font]['fonts'][$full_font])) {
      return $available_fonts[$font]['fonts'][$full_font];
    }
    else {
      return $available_fonts[$font];
    }
  }
  else{
    // Try the string without the last word to determine the parent
    $font = substr($font, 0, strrpos($font, " "));
    return _google_fonts_get_font_info($font, $full_font);
  }
}

/**
 * Filter function to filter out the disabled Google Fonts.
 */
function _google_fonts_filter_enabled_fonts($value) {
  if ($value == '0') {
    return FALSE;
  }
  return TRUE;
}

/**
 * Create the CSS file and store it locally.
 */
function _google_fonts_cache($file_contents, $reset = FALSE) {
  
  $directory = file_build_uri('google_fonts');
  $file_destination = $directory . '/google_fonts.css';
  
  if (!file_exists($file_destination) || $reset) {
    // Check that the files directory is writable
    if (file_prepare_directory($directory, FILE_CREATE_DIRECTORY)) {
      return file_unmanaged_save_data($file_contents, $file_destination, FILE_EXISTS_REPLACE);
    }
  }
  else {
    return $file_destination;
  }
}